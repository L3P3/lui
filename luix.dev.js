"use strict";/*
 lui.js web framework 2.3.0
 inspired by react and mithril
 l3p3.de 2025
*/
{let e=null,f=!e,g=e,h=0,n=0,t=0,w=!f,x=[],y=[];
const A={},aa={},ba={},ca=[],B=[],da={},C=e,D=f,E=w,F=Array,G=Object,I=G.assign,J=G.keys,ea=G.values,fa=G.freeze,ha=G.isFrozen,ia=document,K=window,ja=K.performance||Date,ka=a=>(a===void 0&&L("model state must not contain undefined, missing return?"),ha(a)||(fa(a).constructor!==F&&(a.constructor!==G&&L("model state must not contain shit like "+a.constructor.name),a=ea(a)),a.forEach(ka))),la=({u:{B:a}})=>a===M?"list":a.name_||a.name||"?",N=()=>{const a=[];let b=g,c=C;if(g){for(a[0]="$"+(h-1);b[0].j!==
0;)a.unshift(b[0].j===1?`hook_map[${typeof b[0].L==="object"?b[0].L.id:b[0].L}]`:"hook_sub"),b=b[0].X;b=b[0].V}for(;b;)a.unshift(la(b)+(c!==C?":"+c:"")),c=b.T,b=b.K;return a.join("/")||"-"},ma=(...a)=>{console.log(...a)},na=a=>{ma("lui "+N()+": "+a)},L=a=>{throw Error("lui: "+a);},oa=a=>{ma("lui "+a+": error in callback");e=C},O=(a,b,c)=>{try{return a(...b)}catch(d){throw oa(c),d;}},pa=(a,b)=>{a===b||a&&b&&JSON.stringify(J(a))===JSON.stringify(J(b))||L("object keys mismatch")},P=(a,b,c)=>{g||L("hook called outside of hook context");
c&&(c.constructor!==F&&L("deps must be in an array"),c.length===0&&L("deps must not be empty"));b&&g[0].j!==0&&L("hook called outside of component rendering");a!==C&&h<g.length&&(g[h].j!==a&&L("inconsistent hook order"),g[h].h&&qa(g[h].h,c))},T=(a,b)=>{P(C,E,C);a!==Q(a,a)&&L(b+" changed between renderings")},qa=(a,b)=>{b?a.length!==b.length&&L("deps length changed"):a.length>0&&L("deps presence changed")},sa=a=>new Function("a","b",`return a!==b&&(${a.join("||")})`),U=a=>{const b=(a=J(a)).join(",");
return ba[b]||(a.length===0&&L("object empty"),a.some(c=>(c.includes("-")||"0123456789".includes(c.charAt(0)))&&L("invalid key: "+c)),ba[b]=sa(a.map(c=>`a.${c}!==b.`+c)))},ta=(a,b)=>(pa(a,b),a===b?B:J(a).filter(c=>a[c]!==b[c])),V=a=>a?(a.length===0&&L("deps must not be empty"),ca[a.length]||(ca[a.length]=sa(a.map((b,c)=>`a[${c}]!==b[${c}]`)))):C,M=(a,b)=>{const c=e,d=b,p=c.A+1;g=c.v;h=1;c.H=E;if(c.u.B!==M){var k=C;try{k=(0,c.u.B)(c.u.o||da)}catch(R){if(R!==A)throw R;}var m=c.i;typeof k!=="object"&&
L("components need to return child list or null");if(k){m&&(a=m,b=C);var r=k.length,l;typeof r!=="number"&&L("childs must be returned in a list");r===0&&L("returned childs list empty");c.l&&r!==c.l.length&&L("returned childs count changed");var u=c.l||(c.l=(new F(r)).fill(C));do{var q=u[--r];if((l=k[r])&&l!==D){e.A===0&&l.length!=C&&L("root component signature changed, see https://github.com/L3P3/lui/issues/53");!l.B&&L("invalid node type at "+r);q&&q.u.B!==l.B&&L("node type changed at "+r);if(f=
!q)u[r]=e=q={u:l,U:l.o&&U(l.o),K:c,A:p,T:r,v:[],l:C,i:C,m:C,H:E},e.v[0]={j:0,V:q},M(a,b),q.i&&a.insertBefore(q.m=q.i,b);else if(pa(q.u.o,l.o),l.o&&q.U(q.u.o,l.o))(e=q).u=l,M(a,b);q.m&&(b=q.m)}else q&&(W(q,a),u[r]=C)}while(r>0)}else if(c.l){for(r of c.l)r&&W(r,a);c.l=C}m||(c.m=b!==d?b:C)}else{r=c.u.o.B;var v=c.u.o.P;q=c.u.o.o;typeof v==="object"&&v&&v.constructor===F||L("list_data must be an array");typeof q!=="object"&&L("props must be an object");T(r,"item component");T(q&&J(q).join(","),"common props");
u=v.length;let R=D;if(!(Q(u,u)+u<=0)){l=X();k={};m=[];v=u>0&&ua(v,k,m);u||X();if(l.N){R=q&&l.U(q,l.ea);for(var H of l.da)H in k||(W(l.N[H],a),delete l.N[H]);l.ea=q;l.da=m}else l.N={},l.Z=v?U(k[m[0]]):C,l.da=m,l.U=(l.ea=q)&&U(q);for(H=c.l=new F(u);u>0;){const S=m[--u];let z=l.N[S];if(f=!z)l.N[S]=e=z={u:{B:r,o:I({I:k[S]},q)},U:C,K:c,A:p,T:u,v:[],l:C,i:C,m:C,H:E},e.v[0]={j:0,V:z},M(a,b),z.i&&a.insertBefore(z.m=z.i,b);else{const ra=va(z);ra&&ra.nextSibling!==b&&wa(z,a,b);if(R||v&&l.Z(k[S],z.u.o.I))(e=
z).u.o=I({I:k[S]},q),M(a,b)}(H[z.T=u]=z).m&&(b=z.m)}c.m=b!==d?b:C}}},W=(a,b)=>{b&&a.i&&(a.i.remove(),b=C);if(a.l)for(const c of a.l)c&&W(c,b);Y(a.v);if(a.H){let c,d;(!(d=x[c=a.A])||(c=d.indexOf(a))<0)&&(!(d=y[c])||(c=d.indexOf(a))<0)||d.splice(c,1)}},Y=a=>{let b,c=a.length;for(;c>1;)switch((b=a[--c]).j){case 3:b.M&&b.M(...b.h);break;case 4:b.h=B;break;case 7:xa(b);break;case 11:Y(b.v)}},ua=(a,b,c)=>{const d=typeof a[0]==="object",p=X();p.ga||(a[0]!==C&&["object","string","number"].includes(p.ga=typeof a[0])||
L("item type invalid"),d&&(!["string","number"].includes(p.ja=typeof a[0].id)&&L("item id type invalid"),p.keys=J(a[0]).join(",")));for(const k of a)k===C&&L("item is null"),typeof k!==p.ga&&L("item type changed"),d&&(typeof k.id!==p.ja&&L("item id type changed"),J(k).join(",")!==p.keys&&L("item keys differ of "+k.id));for(const k of a)a=d?k.id:k,a in b&&L("item key not unique: "+a),b[a]=k,c.push(a);return d},va=a=>{if(a.i)return a.i;let b;a=(b=a.l)?b.length:0;let c,d;for(;a>0;)if((d=b[--a])&&(c=
va(d)))return c;return C},wa=(a,b,c)=>{if(a.i)return b.insertBefore(a.i,c);if(a.m){let d=a.l.length;do a.l[--d]&&(c=wa(a.l[d],b,c));while(d>0)}return c},ya=a=>{for(;a[0].j!==0;){if(!a[0].Y.J)return C;a[0].Y.J=E;a=a[0].X}return a[0].V},Aa=a=>(a=ya(a))&&za(a),za=a=>!a.H&&(a.H=D,x[a.A]?x[a.A].push(a):x[a.A]=[a],w||Ba()),Ca=()=>{P(C,E,C);const a=ya(g);a&&(a.H=D,y[a.A]?y[a.A].push(a):y[a.A]=[a])},Da=(a,b)=>{P(3,E,b);if(h>=g.length)g[h]={j:3,G:V(b),h:b=b||B,M:a(...b)||C};else if(b){const c=g[h];c.G(c.h,
b)&&(c.M&&c.M(...c.h),c.M=a(...(c.h=b))||C)}g[h].M?.then&&L("effect function must be synchronous");++h},Ea=a=>{P(5,E,C);if(h<g.length)return g[h++].g;const b=g,c=[a,d=>{c[0]!==d&&(c[0]=d,Aa(b));return d},()=>c[0]];g[h++]={j:5,g:c};return c},X=a=>(P(6,E,C),(h<g.length?g[h++]:g[h++]={j:6,g:a===void 0?{}:a}).g),Fa=(a,b)=>(P(8,E,b),h>=g.length?(g[h++]={j:8,G:V(b),h:b=b||B,g:a(...b)}).g:b&&g[h].G(g[h].h,b)?g[h].g=a(...(g[h++].h=b)):g[h++].g),Q=(a,b)=>(P(9,E,C),h<g.length?(b=g[h].g,g[h++].g=a):g[h++]={j:9,
g:a},b),Ga=(a,b)=>(a=setTimeout(()=>b(D),a),()=>clearTimeout(a)),xa=a=>{for(const b of a.$)Y(a.O[b])},Ha=(a,b,c)=>({ba:c.ca,ha:a,aa:n,fa:f?n:n+b}),Z=a=>{typeof a==="object"&&a||L("object required");const b=Q(a,C);return b?ta(b,a):J(a)},Ia=a=>{T(!a,"attributes presence");const b=e.i;if(a){for(const c of Z(a)){c.length>1&&c.charAt(0).toLowerCase()!==c.charAt(0)&&L("capital prop: "+c);switch(c.charCodeAt(0)){case 70:typeof a.F==="object"&&a.F||L("invalid css flags");b.className=J(a.F).filter(d=>a.F[d]).join(" ");
continue;case 82:typeof a.R!=="function"&&L("invalid ref"),a.R(b);case 67:case 68:case 83:continue}c.charCodeAt(0)<97&&L("invalid prop: "+c);b[c]=a[c]}T(!a.D,"dataset presence");if(a.D)for(const c of Z(a.D))b.dataset[c]=a.D[c];T(!a.S,"style presence");if(a.S)for(const c of Z(a.S))b.style[c]=a.S[c]}return b},Ja=(a,b,c)=>(typeof a==="string"&&L("component expected, use node_dom instead"),c&&c.constructor!==F&&L("invalid childs type"),{B:a,o:b?c?(b.C=c,b):b:c?{C:c}:C}),Ba=()=>{f=n<=0;n=ja.now();t&&cancelAnimationFrame(t);
w=D;t=0;var a;let b=0;for(;(a=x).length;){++b>10&&L("rerender loop detected");x=[];for(const c of a)if(c)for(e of c)if(e.H){if(e.i)M(C,C);else{let d=C,p=e.m,k=e,m=e;for(;!(a=(k=k.K).i););do{let r=m.T;const {l}=m=m.K,u=l.length;for(;++r<u&&l[r]&&!(d=l[r].m););}while(!d&&m!==k);m=e;M(a,d);if(m.m!==p)for(;!(m=m.K).i;){p=C;for(const r of m.l)if(r&&(p=r.m))break;if(p===m.m)break;m.m=p}}f=E}}w=E;e=g=C;y.length&&(x=y,y=a,Ka())},Ka=()=>t||(t=requestAnimationFrame(Ba)),La=a=>{var b=A[a];if(!b){a.startsWith("#")&&
L("dom: unknown handle");const c=a.indexOf("[");b=c<0?a:a.substr(0,c);(b.length===0||b!==b.toLowerCase()||b.includes(" ")||b.includes("#")||b.includes("."))&&L("dom: invalid tag");A[a]=b=ia.createElement(b);if(c>0){!a.endsWith("]")&&L("dom: ] missing");for(const d of a.substring(c+1,a.length-1).split("]["))!d&&L("dom: empty attribute"),(d.includes("[")||d.includes("]"))&&L("dom: attributes screwed up"),a=d.indexOf("="),d.includes(" ")&&(a<0||d.indexOf(" ")<a)&&L("dom: space in attribute name"),a>
0?b[d.substr(0,a)]=d.substr(a+1):b[d]=D}}return b},Ma=a=>{a&&typeof a==="string"||L("dom: descriptor string expected");let b=aa[a];if(!b){const c=La(a);aa[a]=b=d=>(f&&(e.i=c.cloneNode(D)),Ia(d),d&&d.C||C);b.name_="$"+a}return b};K.onerror=()=>(e&&na("error in component"),x=y=[],E);K.lui={defer:()=>(e&&L("defer while rendering"),w=D,Ka()),defer_end:()=>(e&&L("defer_end while rendering"),w||L("nothing was deferred"),Ba()),dom_define:(a,b,c)=>{A["#"+a]&&L("dom_define: handle exists");b=La(b);c&&(c&&(c.C&&L("dom_define cannot have childs"),c.R&&L("dom_define cannot have a ref")),b=b.cloneNode(D),c.D&&(I(b.dataset,c.D),delete c.D),c.S&&(I(b.style,c.S),delete c.S),I(b,c));A["#"+a]=b},hook_assert:a=>{P(C,E,C);if(!a)throw A;},hook_async:(a,b,c)=>{P(4,E,b);let d;const p=N();if((h<g.length?
(d=g[h++],E):d=g[h++]={j:4,G:V(b),h:b||B,g:C})||b&&d.G(d.h,b)&&(d.h=b)){c!==void 0&&(d.g=c);const k=g;a(...d.h).then(m=>d.g!==m&&d.h===b&&(d.g=m,Aa(k))).catch(m=>{oa(p);throw m;})}return d.g},hook_callback:(a,b)=>{const c=h>=g.length?N():"";!b?.length&&L("deps required, use hook_static instead");const d=X();d.h&&qa(d.h,b);d.h=b;return d.ia||(d.ia=(...p)=>O(a,[...d.h,...p],c))},hook_delay:a=>{const [b,c]=Ea(E);Da(Ga,[a,c]);return b},hook_dom:(a,b)=>(P(C,D,C),e.i?f&&e.K&&L("hook_dom called twice"):
f||L("hook_dom skipped before"),b&&(b.C&&L("hook_dom cannot have childs"),b.R&&L("hook_dom cannot have a ref")),e.i===C&&(e.i=La(a).cloneNode(D)),Ia(b||C)),hook_effect:Da,hook_map:(a,b,c)=>{P(7,E,c);let d=C,p=D;if(h<g.length)if((d=g[h]).W!==a)xa(d),d=C;else if(!d.J||c&&d.G(d.h,c))d.h=c||B,d.J=D;else{if(b===d.P)return++h,d.g;p=E}const k=f,m=g,r=++h,l={},u=[],q=b.length>0&&ua(b,l,u);b.length===0&&X();if(d){if(d.g=[],d.P!==b){d.P=b;for(const v of d.$)v in l||(Y(d.O[v]),delete d.O[v])}}else g[r-1]=d=
{j:7,G:V(c),h:c||B,g:[],J:D,W:a,Z:q?U(b[0]):C,$:[],O:{},P:b};for(const v of u){b=d.O[v];if(f=!b)d.O[v]=b=[{j:1,X:m,Y:d,L:C,g:C}];if(p||f||(q?d.Z(l[v],b[0].L):l[v]!==b[0].L)){g=b;h=1;try{b[0].g=a(b[0].L=l[v],...d.h)}catch(H){if(H!==A)throw H;}g=m}d.g.push(b[0].g)}f=k;g=m;h=r;d.$=u;return d.g},hook_memo:Fa,hook_model:a=>{P(10,E,C);typeof a==="object"&&a||L("mutations object required");typeof a.init!=="function"&&L("init mutation required for initial value");if(h<g.length)return g[h++].g;const b=g,c=
N(),d=[O(a.init,[C],c+" -> #init"),{}];O(ka,[d[0]],c+" -> #init");for(const p of J(a))d[1][p]=(...k)=>{k=O(a[p],[d[0],...k],c+" -> #"+p);d[0]!==k&&(O(ka,[k],c+" -> #"+p),d[0]=k,Aa(b));return k};g[h++]={j:10,g:d};return d},hook_object_changes:Z,hook_prev:Q,hook_rerender:Ca,hook_state:Ea,hook_static:X,hook_sub:(a,b)=>{P(11,E,b);let c=C;if(h<g.length)if((c=g[h]).W!==a)Y(c.v),c=C;else if(!c.J||b&&c.G(c.h,b))b&&(c.h=b),c.J=D;else return++h,c.g;const d=f,p=g,k=h;if(f=!c)(g[h]=c={j:11,G:V(b),h:b||B,g:C,
W:a,J:D,v:[]}).v[0]={j:2,X:g,Y:c};g=c.v;h=1;try{c.g=a(...c.h)}catch(m){if(m!==A)throw m;}f=d;g=p;h=k+1;return c.g},hook_transition:(a,b)=>{const c=X({ca:a});a=Fa(Ha,[a,b,c]);return c.ca=a.fa<=n?a.ha:(Ca(),a.aa===n?a.ba:a.ba+(a.ha-a.ba)*(n-a.aa)/(a.fa-a.aa))},init:(a,b=ia.body,c=C)=>{typeof a!=="function"&&L("no init function specified");b.innerHTML!=C||L("invalid component_ element");b._lui_used&&L("root element already mounted");b._lui_used=1;b.innerHTML="";b={u:{B:a,o:c},U:C,K:C,A:0,T:0,v:[],l:C,
i:b,m:b,H:E};b.v[0]={j:0,V:b};a.name_="$root";e=g=C;za(b)},node:Ja,node_dom:(a,b,c)=>Ja(Ma(a),b,c),node_map:(a,b,c)=>Ja(M,{B:a,P:b,o:c||C}),now:()=>n}}
