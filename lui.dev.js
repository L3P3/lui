"use strict";/*
 lui.js web framework 2.2.3
 inspired by react and mithril
 l3p3.de 2025
*/
{let d=null,e=!d,g=d,h=0,k=0,w=0,x=!e,y=[],z=[];
const A={},aa={},ba={},ca=[],B=[],da={},C=d,D=e,G=x,H=Array,I=Object,J=I.assign,L=I.keys,ea=I.values,fa=I.freeze,ha=I.isFrozen,ia=document,M=window,ja=M.performance||Date,O=a=>(a===void 0&&N("model state must not contain undefined, missing return?"),ha(a)||(fa(a).constructor!==H&&(a.constructor!==I&&N("model state must not contain shit like "+a.constructor.name),a=ea(a)),a.forEach(O))),ka=({o:{v:a}})=>a===R?"list":a.name_||a.name||"?",S=()=>{const a=[];let b=d,c=C;for(d&&(a[0]="$"+h);b;)a.unshift(ka(b)+
(c!==C?":"+c:"")),c=b.L,b=b.G;return a.join("/")||"-"},la=(...a)=>{console.log(...a)},ma=a=>{la("lui "+S()+": "+a)},N=a=>{throw Error("lui: "+a);},na=a=>{la("lui "+a+": error in callback");d=C},T=(a,b,c)=>{try{return a(...b)}catch(f){throw na(c),f;}},oa=(a,b)=>{a===b||a&&b&&JSON.stringify(L(a))===JSON.stringify(L(b))||N("object keys mismatch")},U=(a,b)=>{g||N("hook called outside of hook context");b&&(b.constructor!==H&&N("deps must be in an array"),b.length===0&&N("deps must not be empty"));a!==
C&&h<g.length&&(g[h].B!==a&&N("inconsistent hook order"),g[h].m&&pa(g[h].m,b))},W=(a,b)=>{U(C,C);a!==V(a,a)&&N(b+" changed between renderings")},pa=(a,b)=>{b?a.length!==b.length&&N("deps length changed"):a.length>0&&N("deps presence changed")},qa=a=>new Function("a","b",`return a!==b&&(${a.join("||")})`),ra=a=>{const b=(a=L(a)).join(",");return ba[b]||(a.length===0&&N("object empty"),a.some(c=>(c.includes("-")||"0123456789".includes(c.charAt(0)))&&N("invalid key: "+c)),ba[b]=qa(a.map(c=>`a.${c}!==b.`+
c)))},sa=(a,b)=>(oa(a,b),a===b?B:L(a).filter(c=>a[c]!==b[c])),ta=a=>a?(a.length===0&&N("deps must not be empty"),ca[a.length]||(ca[a.length]=qa(a.map((b,c)=>`a[${c}]!==b[${c}]`)))):C,R=(a,b)=>{const c=d,f=b,t=c.u+1;g=c.N;h=0;c.A=G;if(c.o.v!==R){var m=C;try{m=(0,c.o.v)(c.o.l||da)}catch(P){if(P!==A)throw P;}var n=c.g;typeof m!=="object"&&N("components need to return child list or null");if(m){n&&(a=n,b=C);var q=m.length,l;typeof q!=="number"&&N("childs must be returned in a list");q===0&&N("returned childs list empty");
c.h&&q!==c.h.length&&N("returned childs count changed");var u=c.h||(c.h=(new H(q)).fill(C));do{var p=u[--q];if((l=m[q])&&l!==D){d.u===0&&l.length!=C&&N("root component signature changed, see https://github.com/L3P3/lui/issues/53");!l.v&&N("invalid node type at "+q);p&&p.o.v!==l.v&&N("node type changed at "+q);if(e=!p)u[q]=d=p={o:l,M:l.l&&ra(l.l),G:c,u:t,L:q,N:[],h:C,g:C,i:C,A:G},R(a,b),p.g&&a.insertBefore(p.i=p.g,b);else if(oa(p.o.l,l.l),l.l&&p.M(p.o.l,l.l))(d=p).o=l,R(a,b);p.i&&(b=p.i)}else p&&(X(p,
a),u[q]=C)}while(q>0)}else if(c.h){for(q of c.h)q&&X(q,a);c.h=C}n||(c.i=b!==f?b:C)}else{q=c.o.l.v;var r=c.o.l.V;p=c.o.l.l;typeof r==="object"&&r&&r.constructor===H||N("list_data must be an array");typeof p!=="object"&&N("props must be an object");W(q,"item component");W(p&&L(p).join(","),"common props");u=r.length;let P=D;if(!(V(u,u)+u<=0)){l=Y();m={};n=[];var E;if(E=u>0){E=typeof r[0]==="object";const F=Y();F.T||(r[0]!==C&&["object","string","number"].includes(F.T=typeof r[0])||N("item type invalid"),
E&&(!["string","number"].includes(F.W=typeof r[0].id)&&N("item id type invalid"),F.keys=L(r[0]).join(",")));for(var v of r)v===C&&N("item is null"),typeof v!==F.T&&N("item type changed"),E&&(typeof v.id!==F.W&&N("item id type changed"),L(v).join(",")!==F.keys&&N("item keys differ of "+v.id));for(var K of r)v=E?K.id:K,v in m&&N("item key not unique: "+v),m[v]=K,n.push(v)}K=E;u||Y();if(l.K){P=p&&l.M(p,l.P);for(var Q of l.O)Q in m||(X(l.K[Q],a),delete l.K[Q]);l.P=p;l.O=n}else l.K={},l.U=K?ra(m[n[0]]):
C,l.O=n,l.M=(l.P=p)&&ra(p);for(Q=c.h=new H(u);u>0;){v=n[--u];r=l.K[v];if(e=!r)l.K[v]=d=r={o:{v:q,l:J({I:m[v]},p)},M:C,G:c,u:t,L:u,N:[],h:C,g:C,i:C,A:G},R(a,b),r.g&&a.insertBefore(r.i=r.g,b);else if((E=ua(r))&&E.nextSibling!==b&&va(r,a,b),P||K&&l.U(m[v],r.o.l.I))(d=r).o.l=J({I:m[v]},p),R(a,b);(Q[r.L=u]=r).i&&(b=r.i)}c.i=b!==f?b:C}}},X=(a,b)=>{b&&a.g&&(a.g.remove(),b=C);if(a.h)for(var c of a.h)c&&X(c,b);b=a.N;let f=b.length;for(;f>1;)switch((c=b[--f]).B){case 3:c.H&&c.H(...c.m);break;case 4:c.m=B}if(a.A){let t,
m;(!(m=y[t=a.u])||(t=m.indexOf(a))<0)&&(!(m=z[t])||(t=m.indexOf(a))<0)||m.splice(t,1)}},ua=a=>{if(a.g)return a.g;let b;a=(b=a.h)?b.length:0;let c,f;for(;a>0;)if((f=b[--a])&&(c=ua(f)))return c;return C},va=(a,b,c)=>{if(a.g)return b.insertBefore(a.g,c);if(a.i){let f=a.h.length;do a.h[--f]&&(c=va(a.h[f],b,c));while(f>0)}return c},Z=a=>!a.A&&(a.A=D,y[a.u]?y[a.u].push(a):y[a.u]=[a],x||wa()),Y=a=>(U(6,C),(h<g.length?g[h++]:g[h++]={B:6,j:a===void 0?{}:a}).j),V=(a,b)=>(U(9,C),h<g.length?(b=g[h].j,g[h++].j=
a):g[h++]={B:9,j:a},b),xa=a=>{typeof a==="object"&&a||N("object required");const b=V(a,C);return b?sa(b,a):L(a)},ya=a=>{W(!a,"attributes presence");const b=d.g;if(a){for(const c of xa(a)){c.length>1&&c.charAt(0).toLowerCase()!==c.charAt(0)&&N("capital prop: "+c);switch(c.charCodeAt(0)){case 70:typeof a.F==="object"&&a.F||N("invalid css flags");b.className=L(a.F).filter(f=>a.F[f]).join(" ");continue;case 82:typeof a.R!=="function"&&N("invalid ref"),a.R(b);case 67:case 68:case 83:continue}c.charCodeAt(0)<
97&&N("invalid prop: "+c);b[c]=a[c]}W(!a.D,"dataset presence");if(a.D)for(const c of xa(a.D))b.dataset[c]=a.D[c];W(!a.S,"style presence");if(a.S)for(const c of xa(a.S))b.style[c]=a.S[c]}return b},za=(a,b,c)=>(typeof a==="string"&&N("component expected, use node_dom instead"),c&&c.constructor!==H&&N("invalid childs type"),{v:a,l:b?c?(b.C=c,b):b:c?{C:c}:C}),wa=()=>{e=k<=0;k=ja.now();w&&cancelAnimationFrame(w);x=D;w=0;var a;let b=0;for(;(a=y).length;){++b>10&&N("rerender loop detected");y=[];for(const c of a)if(c)for(d of c)if(d.A){if(d.g)R(C,
C);else{let f=C,t=d.i,m=d,n=d;for(;!(a=(m=m.G).g););do{let q=n.L;const {h:l}=n=n.G,u=l.length;for(;++q<u&&l[q]&&!(f=l[q].i););}while(!f&&n!==m);n=d;R(a,f);if(n.i!==t)for(;!(n=n.G).g;){t=C;for(const q of n.h)if(q&&(t=q.i))break;if(t===n.i)break;n.i=t}}e=G}}x=G;d=g=C;z.length&&(y=z,z=a,Aa())},Aa=()=>w||(w=requestAnimationFrame(wa)),Ba=a=>{var b=A[a];if(!b){a.startsWith("#")&&N("dom: unknown handle");const c=a.indexOf("[");b=c<0?a:a.substr(0,c);(b.length===0||b!==b.toLowerCase()||b.includes(" ")||b.includes("#")||
b.includes("."))&&N("dom: invalid tag");A[a]=b=ia.createElement(b);if(c>0){!a.endsWith("]")&&N("dom: ] missing");for(const f of a.substring(c+1,a.length-1).split("]["))!f&&N("dom: empty attribute"),(f.includes("[")||f.includes("]"))&&N("dom: attributes screwed up"),a=f.indexOf("="),f.includes(" ")&&(a<0||f.indexOf(" ")<a)&&N("dom: space in attribute name"),a>0?b[f.substr(0,a)]=f.substr(a+1):b[f]=D}}return b},Ca=a=>{a&&typeof a==="string"||N("dom: descriptor string expected");let b=aa[a];if(!b){const c=
Ba(a);aa[a]=b=f=>(e&&(d.g=c.cloneNode(D)),ya(f),f&&f.C||C);b.name_="$"+a}return b};M.onerror=()=>(d&&ma("error in component"),y=z=[],G);M.lui={defer:()=>(d&&N("defer while rendering"),x=D,Aa()),defer_end:()=>(d&&N("defer_end while rendering"),x||N("nothing was deferred"),wa()),dom_define:(a,b,c)=>{A["#"+a]&&N("dom_define: handle exists");b=Ba(b);c&&(c&&(c.C&&N("dom_define cannot have childs"),c.R&&N("dom_define cannot have a ref")),b=b.cloneNode(D),c.D&&(J(b.dataset,c.D),delete c.D),c.S&&(J(b.style,c.S),delete c.S),J(b,c));A["#"+a]=b},hook_assert:a=>{U(C,C);if(!a)throw A;},hook_async:(a,b,c)=>{U(4,b);let f;const t=S();if((h<g.length?
(f=g[h++],G):f=g[h++]={B:4,J:ta(b),m:b||B,j:C})||b&&f.J(f.m,b)&&(f.m=b)){c!==void 0&&(f.j=c);const m=d;a(...f.m).then(n=>f.j!==n&&f.m===b&&(f.j=n,Z(m))).catch(n=>{na(t);throw n;})}return f.j},hook_dom:(a,b)=>(U(C,C),d.g?e&&d.G&&N("hook_dom called twice"):e||N("hook_dom skipped before"),b&&(b.C&&N("hook_dom cannot have childs"),b.R&&N("hook_dom cannot have a ref")),d.g===C&&(d.g=Ba(a).cloneNode(D)),ya(b||C)),hook_effect:(a,b)=>{U(3,b);if(h>=g.length)g[h]={B:3,J:ta(b),m:b=b||B,H:a(...b)||C};else if(b){const c=
g[h];c.J(c.m,b)&&(c.H&&c.H(...c.m),c.H=a(...(c.m=b))||C)}g[h].H?.then&&N("effect function must be synchronous");++h},hook_memo:(a,b)=>(U(8,b),h>=g.length?(g[h++]={B:8,J:ta(b),m:b=b||B,j:a(...b)}).j:b&&g[h].J(g[h].m,b)?g[h].j=a(...(g[h++].m=b)):g[h++].j),hook_model:a=>{U(10,C);typeof a==="object"&&a||N("mutations object required");typeof a.init!=="function"&&N("init mutation required for initial value");if(h<g.length)return g[h++].j;const b=d,c=S(),f=[T(a.init,[C],c+" -> #init"),{}];T(O,[f[0]],c+" -> #init");
for(const t of L(a))f[1][t]=(...m)=>{m=T(a[t],[f[0],...m],c+" -> #"+t);f[0]!==m&&(T(O,[m],c+" -> #"+t),f[0]=m,Z(b))};g[h++]={B:10,j:f};return f},hook_prev:V,hook_rerender:()=>{U(C,C);const a=d;a.A=D;z[a.u]?z[a.u].push(a):z[a.u]=[a]},hook_state:a=>{U(5,C);if(h<g.length)return g[h++].j;const b=d,c=[a,f=>{c[0]!==f&&(c[0]=f,Z(b))},()=>c[0]];g[h++]={B:5,j:c};return c},hook_static:Y,init:(a,b=ia.body,c=C)=>{typeof a!=="function"&&N("no init function specified");b.innerHTML!=C||N("invalid component_ element");
b._lui_used&&N("root element already mounted");b._lui_used=1;b.innerHTML="";b={o:{v:a,l:c},M:C,G:C,u:0,L:0,N:[],h:C,g:b,i:b,A:G};a.name_="$root";d=g=C;Z(b)},node:za,node_dom:(a,b,c)=>za(Ca(a),b,c),node_map:(a,b,c)=>za(R,{v:a,V:b,l:c||C}),now:()=>k}}
