'use strict';/*
 lui.js web frame work 2.2.0
 inspired by react and mithril
 L3P3.de 2024
*/
{let d=null,e=!d,g=d,h=0,k=0,w=0,x=!e,y=[],z=[];
const A={},aa={},ba={},ca=[],B=[],da={},C=d,D=e,G=x,H=Array,I=Object,J=I.assign,L=I.keys,ea=I.freeze,fa=I.isFrozen,ha=document,M=window,ia=M.performance||Date,O=a=>(void 0===a&&N("model state must not contain undefined, missing return?"),fa(a)||(ea(a).constructor!==H&&(a.constructor!==I&&N("model state must not contain shit like "+a.constructor.name),a=I.values(a)),a.forEach(O))),ja=({o:{u:a}})=>a===R?"list":a.name_||a.name||"?",S=()=>{const a=[];let b=d,c=C;for(d&&(a[0]="$"+h);b;)a.unshift(ja(b)+
(c!==C?":"+c:"")),c=b.K,b=b.B;return a.join("/")||"-"},ka=(...a)=>{console.log(...a)},la=a=>{ka("lui "+S()+": "+a)},N=a=>{throw Error("lui: "+a);},ma=a=>{ka("lui "+a+": error in callback");d=C},T=(a,b,c)=>{try{return a(...b)}catch(f){throw ma(c),f;}},na=(a,b)=>{a===b||a&&b&&JSON.stringify(L(a))===JSON.stringify(L(b))||N("object keys mismatch")},U=(a,b)=>{g||N("hook called outside of hook context");b&&(b.constructor!==H&&N("deps must be in an array"),0===b.length&&N("deps must not be empty"));a!==
C&&h<g.length&&(g[h].A!==a&&N("inconsistent hook order"),g[h].m&&oa(g[h].m,b))},W=(a,b)=>{U(C,C);a!==V(a,a)&&N(b+" changed between renderings")},oa=(a,b)=>{b?a.length!==b.length&&N("deps length changed"):0<a.length&&N("deps presence changed")},pa=a=>new Function("a","b",`return a!==b&&(${a.join("||")})`),qa=a=>{const b=(a=L(a)).join(",");return ba[b]||(0===a.length&&N("object empty"),a.some(c=>(c.includes("-")||"0123456789".includes(c.charAt(0)))&&N("invalid key: "+c)),ba[b]=pa(a.map(c=>`a.${c}!==b.`+
c)))},ra=(a,b)=>(na(a,b),a===b?B:L(a).filter(c=>a[c]!==b[c])),sa=a=>a?(0===a.length&&N("deps must not be empty"),ca[a.length]||(ca[a.length]=pa(a.map((b,c)=>`a[${c}]!==b[${c}]`)))):C,R=(a,b)=>{const c=d,f=b,t=c.s+1;g=c.M;h=0;c.v=G;if(c.o.u!==R){var m=C;try{m=(0,c.o.u)(c.o.l||da)}catch(P){if(P!==A)throw P;}var n=c.g;"object"!==typeof m&&N("components need to return child list or null");if(m){n&&(a=n,b=C);var q=m.length,l;"number"!==typeof q&&N("childs must be returned in a list");0===q&&N("returned childs list empty");
c.h&&q!==c.h.length&&N("returned childs count changed");var u=c.h||(c.h=(new H(q)).fill(C));do{var p=u[--q];if((l=m[q])&&l!==D){0===d.s&&l.length!=C&&N("root component signature changed, see https://github.com/L3P3/lui/issues/53");!l.u&&N("invalid node type at "+q);p&&p.o.u!==l.u&&N("node type changed at "+q);if(e=!p)u[q]=d=p={o:l,L:l.l&&qa(l.l),B:c,s:t,K:q,M:[],h:C,g:C,i:C,v:G},R(a,b),p.g&&a.insertBefore(p.i=p.g,b);else if(na(p.o.l,l.l),l.l&&p.L(p.o.l,l.l))(d=p).o=l,R(a,b);p.i&&(b=p.i)}else p&&(X(p,
a),u[q]=C)}while(0<q)}else if(c.h){for(q of c.h)q&&X(q,a);c.h=C}n||(c.i=b!==f?b:C)}else{q=c.o.l.u;var r=c.o.l.U;p=c.o.l.l;"object"===typeof r&&r&&r.constructor===H||N("list_data must be an array");"object"!==typeof p&&N("props must be an object");W(q,"item component");W(p&&L(p).join(","),"common props");u=r.length;let P=D;if(!(0>=V(u,u)+u)){l=Y();m={};n=[];var E;if(E=0<u){E="object"===typeof r[0];const F=Y();F.P||(r[0]!==C&&["object","string","number"].includes(F.P=typeof r[0])||N("item type invalid"),
E&&(!["string","number"].includes(F.V=typeof r[0].id)&&N("item id type invalid"),F.keys=L(r[0]).join(",")));for(var v of r)v===C&&N("item is null"),typeof v!==F.P&&N("item type changed"),E&&(typeof v.id!==F.V&&N("item id type changed"),L(v).join(",")!==F.keys&&N("item keys differ of "+v.id));for(var K of r)v=E?K.id:K,v in m&&N("item key not unique: "+v),m[v]=K,n.push(v)}K=E;u||Y();if(l.J){P=p&&l.L(p,l.O);for(var Q of l.N)Q in m||(X(l.J[Q],a),delete l.J[Q]);l.O=p;l.N=n}else l.J={},l.T=K?qa(m[n[0]]):
C,l.N=n,l.L=(l.O=p)&&qa(p);for(Q=c.h=new H(u);0<u;){v=n[--u];r=l.J[v];if(e=!r)l.J[v]=d=r={o:{u:q,l:J({I:m[v]},p)},L:C,B:c,s:t,K:u,M:[],h:C,g:C,i:C,v:G},R(a,b),r.g&&a.insertBefore(r.i=r.g,b);else if((E=ta(r))&&E.nextSibling!==b&&ua(r,a,b),P||K&&l.T(m[v],r.o.l.I))(d=r).o.l=J({I:m[v]},p),R(a,b);(Q[r.K=u]=r).i&&(b=r.i)}c.i=b!==f?b:C}}},X=(a,b)=>{b&&a.g&&(a.g.remove(),b=C);if(a.h)for(var c of a.h)c&&X(c,b);b=a.M;let f=b.length;for(;1<f;)switch((c=b[--f]).A){case 3:c.G&&c.G(...c.m);break;case 4:c.m=B}if(a.v){let t,
m;(!(m=y[t=a.s])||0>(t=m.indexOf(a)))&&(!(m=z[t])||0>(t=m.indexOf(a)))||m.splice(t,1)}},ta=a=>{if(a.g)return a.g;let b;a=(b=a.h)?b.length:0;let c,f;for(;0<a;)if((f=b[--a])&&(c=ta(f)))return c;return C},ua=(a,b,c)=>{if(a.g)return b.insertBefore(a.g,c);if(a.i){let f=a.h.length;do a.h[--f]&&(c=ua(a.h[f],b,c));while(0<f)}return c},Z=a=>!a.v&&(a.v=D,y[a.s]?y[a.s].push(a):y[a.s]=[a],x||va()),Y=a=>(U(6,C),(h<g.length?g[h++]:g[h++]={A:6,j:void 0===a?{}:a}).j),V=(a,b)=>(U(9,C),h<g.length?(b=g[h].j,g[h++].j=
a):g[h++]={A:9,j:a},b),wa=a=>{"object"===typeof a&&a||N("object required");const b=V(a,C);return b?ra(b,a):L(a)},xa=a=>{W(!a,"attributes presence");const b=d.g;if(a){for(const c of wa(a)){1<c.length&&c.charAt(0).toLowerCase()!==c.charAt(0)&&N("capital prop: "+c);switch(c.charCodeAt(0)){case 70:"object"===typeof a.F&&a.F||N("invalid css flags");b.className=L(a.F).filter(f=>a.F[f]).join(" ");continue;case 82:"function"!==typeof a.R&&N("invalid ref"),a.R(b);case 67:case 68:case 83:continue}97>c.charCodeAt(0)&&
N("invalid prop: "+c);b[c]=a[c]}W(!a.D,"dataset presence");if(a.D)for(const c of wa(a.D))b.dataset[c]=a.D[c];W(!a.S,"style presence");if(a.S)for(const c of wa(a.S))b.style[c]=a.S[c]}return b},ya=(a,b,c)=>("string"===typeof a&&N("component expected, use node_dom instead"),c&&c.constructor!==H&&N("invalid childs type"),{u:a,l:b?c?(b.C=c,b):b:c?{C:c}:C}),va=()=>{e=0>=k;k=ia.now();w&&cancelAnimationFrame(w);x=D;w=0;var a;let b=0;for(;(a=y).length;){10<++b&&N("rerender loop detected");y=[];for(const c of a)if(c)for(d of c)if(d.v){if(d.g)R(C,
C);else{let f=C,t=d.i,m=d,n=d;for(;!(a=(m=m.B).g););do{let q=n.K;const {h:l}=n=n.B,u=l.length;for(;++q<u&&l[q]&&!(f=l[q].i););}while(!f&&n!==m);n=d;R(a,f);if(n.i!==t)for(;!(n=n.B).g;){t=C;for(const q of n.h)if(q&&(t=q.i))break;if(t===n.i)break;n.i=t}}e=G}}x=G;d=g=C;z.length&&(y=z,z=a,za())},za=()=>w||(w=requestAnimationFrame(va)),Aa=a=>{var b=A[a];if(!b){a.startsWith("#")&&N("dom: unknown handle");const c=a.indexOf("[");b=0>c?a:a.substr(0,c);(0===b.length||b!==b.toLowerCase()||b.includes(" ")||b.includes("#")||
b.includes("."))&&N("dom: invalid tag");A[a]=b=ha.createElement(b);if(0<c){!a.endsWith("]")&&N("dom: ] missing");for(const f of a.substring(c+1,a.length-1).split("]["))!f&&N("dom: empty attribute"),(f.includes("[")||f.includes("]"))&&N("dom: attributes screwed up"),a=f.indexOf("="),f.includes(" ")&&(0>a||f.indexOf(" ")<a)&&N("dom: space in attribute name"),0<a?b[f.substr(0,a)]=f.substr(a+1):b[f]=D}}return b},Ba=a=>{a&&"string"===typeof a||N("dom: descriptor string expected");let b=aa[a];if(!b){const c=
Aa(a);aa[a]=b=f=>(e&&(d.g=c.cloneNode(D)),xa(f),f&&f.C||C);b.name_="$"+a}return b};M.onerror=()=>(d&&la("error in component"),y=z=[],G);M.lui={defer:()=>(d&&N("defer while rendering"),x=D,za()),defer_end:()=>(d&&N("defer_end while rendering"),x||N("nothing was deferred"),va()),dom_define:(a,b,c)=>{A["#"+a]&&N("dom_define: handle exists");b=Aa(b);c&&(c&&(c.C&&N("dom_define cannot have childs"),c.R&&N("dom_define cannot have a ref")),b=b.cloneNode(D),c.D&&(J(b.dataset,c.D),delete c.D),c.S&&(J(b.style,c.S),delete c.S),J(b,c));A["#"+a]=b},hook_assert:a=>{U(C,C);if(!a)throw A;},hook_async:(a,b,c)=>{U(4,b);let f;const t=S();if((h<g.length?
(f=g[h++],G):f=g[h++]={A:4,H:sa(b),m:b||B,j:C})||b&&f.H(f.m,b)&&(f.m=b)){void 0!==c&&(f.j=c);const m=d;a(...f.m).then(n=>f.j!==n&&f.m===b&&(f.j=n,Z(m))).catch(n=>{ma(t);throw n;})}return f.j},hook_dom:(a,b)=>(U(C,C),d.g?e&&d.B&&N("hook_dom called twice"):e||N("hook_dom skipped before"),b&&(b.C&&N("hook_dom cannot have childs"),b.R&&N("hook_dom cannot have a ref")),d.g===C&&(d.g=Aa(a).cloneNode(D)),xa(b||C)),hook_effect:(a,b)=>{U(3,b);if(h>=g.length)g[h]={A:3,H:sa(b),m:b=b||B,G:a(...b)||C};else if(b){const c=
g[h];c.H(c.m,b)&&(c.G&&c.G(...c.m),c.G=a(...(c.m=b))||C)}g[h].G?.then&&N("effect function must be synchronous");++h},hook_memo:(a,b)=>(U(8,b),h>=g.length?(g[h++]={A:8,H:sa(b),m:b=b||B,j:a(...b)}).j:b&&g[h].H(g[h].m,b)?g[h].j=a(...(g[h++].m=b)):g[h++].j),hook_model:a=>{U(10,C);"object"===typeof a&&a||N("mutations object required");"function"!==typeof a.init&&N("init mutation required for initial value");if(h<g.length)return g[h++].j;const b=d,c=S(),f=[T(a.init,[C],c+" -> #init"),{}];T(O,[f[0]],c+" -> #init");
for(const t of L(a))f[1][t]=(...m)=>{m=T(a[t],[f[0],...m],c+" -> #"+t);f[0]!==m&&(T(O,[m],c+" -> #"+t),f[0]=m,Z(b))};g[h++]={A:10,j:f};return f},hook_prev:V,hook_rerender:()=>{U(C,C);const a=d;a.v=D;z[a.s]?z[a.s].push(a):z[a.s]=[a]},hook_state:a=>{U(5,C);if(h<g.length)return g[h++].j;const b=d,c=[a,f=>{c[0]!==f&&(c[0]=f,Z(b))},()=>c[0]];g[h++]={A:5,j:c};return c},hook_static:Y,init:(a,b=ha.body,c=C)=>{"function"!==typeof a&&N("no init function specified");b.innerHTML!=C||N("invalid component_ element");
b._lui_used&&N("root element already mounted");b._lui_used=1;b.innerHTML="";b={o:{u:a,l:c},L:C,B:C,s:0,K:0,M:[],h:C,g:b,i:b,v:G};a.name_="$root";d=g=C;Z(b)},node:ya,node_dom:(a,b,c)=>ya(Ba(a),b,c),node_map:(a,b,c)=>ya(R,{u:a,U:b,l:c||C}),now:()=>k}}