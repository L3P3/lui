'use strict';/*
 lui.js web frame work 2.1.2
 inspired by react and mithril
 L3P3.de 2024
*/
{let d=null,e=!d,g=d,h=0,k=0,w=0,x=!e,y=[],z=[];
const A={},aa={},ba={},ca=[],B=[],da={},C=d,F=e,G=x,H=Array,I=Object,J=I.assign,K=I.keys,ea=I.freeze,fa=I.isFrozen,ha=document,M=window,ia=M.performance||Date,O=a=>(void 0===a&&N("model state must not contain undefined, missing return?"),fa(a)||(ea(a).constructor!==H&&(a.constructor!==I&&N("model state must not contain shit like "+a.constructor.name),a=I.values(a)),a.forEach(O))),ja=({o:{u:a}})=>a===P?"list":a.name_||a.name||"?",ka=()=>{const a=[];let b=d,c=C;for(d&&(a[0]="$"+h);b;)a.unshift(ja(b)+
(c!==C?":"+c:"")),c=b.K,b=b.B;return a.join("/")||"-"},la=(...a)=>{console.log(...a)},ma=a=>{la("lui "+ka()+": "+a)},N=a=>{throw Error("lui: "+a);},na=a=>{la("lui "+a+": error in callback");d=C},S=(a,b,c)=>{try{return a(...b)}catch(f){throw na(c),f;}},oa=(a,b)=>{a===b||a&&b&&JSON.stringify(K(a))===JSON.stringify(K(b))||N("object keys mismatch")},T=(a,b)=>{g||N("hook called outside of hook context");b&&(b.constructor!==H&&N("deps must be in an array"),0===b.length&&N("deps must not be empty"));a!==
C&&h<g.length&&(g[h].A!==a&&N("inconsistent hook order"),g[h].m&&pa(g[h].m,b))},V=(a,b)=>{T(C,C);a!==U(a,a)&&N(b+" changed between renderings")},pa=(a,b)=>{b?a.length!==b.length&&N("deps length changed"):0<a.length&&N("deps presence changed")},qa=a=>new Function("a","b",`return a!==b&&(${a.join("||")})`),P=a=>{const b=(a=K(a)).join(",");return ba[b]||(0===a.length&&N("object empty"),a.some(c=>(c.includes("-")||"0123456789".includes(c.charAt(0)))&&N("invalid key: "+c)),ba[b]=qa(a.map(c=>`a.${c}!==b.`+
c)))},ra=(a,b)=>(oa(a,b),a===b?B:K(a).filter(c=>a[c]!==b[c])),sa=a=>a?ca[a.length]||(0===a.length&&N("deps must not be empty"),ca[a.length]=qa(a.map((b,c)=>`a[${c}]!==b[${c}]`))):C,W=(a,b)=>{const c=d,f=b,t=c.s+1;g=c.M;h=0;c.v=G;if(c.o.u!==P){var m=C;try{m=(0,c.o.u)(c.o.l||da)}catch(Q){if(Q!==A)throw Q;}var n=c.g;"object"!==typeof m&&N("components need to return child list or null");if(m){n&&(a=n,b=C);var q=m.length,l;"number"!==typeof q&&N("childs must be returned in a list");0===q&&N("returned childs list empty");
c.h&&q!==c.h.length&&N("returned childs count changed");var u=c.h||(c.h=(new H(q)).fill(C));do{var p=u[--q];if((l=m[q])&&l!==F){0===d.s&&l.length!=C&&N("root component signature changed, see https://github.com/L3P3/lui/issues/53");!l.u&&N("invalid node type at "+q);p&&p.o.u!==l.u&&N("node type changed at "+q);if(e=!p)u[q]=d=p={o:l,L:l.l&&P(l.l),B:c,s:t,K:q,M:[],h:C,g:C,i:C,v:G},W(a,b),p.g&&a.insertBefore(p.i=p.g,b);else if(oa(p.o.l,l.l),l.l&&p.L(p.o.l,l.l))(d=p).o=l,W(a,b);p.i&&(b=p.i)}else p&&(X(p,
a),u[q]=C)}while(0<q)}else if(c.h){for(q of c.h)q&&X(q,a);c.h=C}n||(c.i=b!==f?b:C)}else{q=c.o.l.u;var r=c.o.l.U;p=c.o.l.l;"object"===typeof r&&r&&r.constructor===H||N("list_data must be an array");"object"!==typeof p&&N("props must be an object");V(q,"item component");V(p&&K(p).join(","),"common props");u=r.length;let Q=F;if(!(0>=U(u,u)+u)){l=Y();m={};n=[];var D;if(D=0<u){D="object"===typeof r[0];const E=Y();E.P||(r[0]!==C&&["object","string","number"].includes(E.P=typeof r[0])||N("item type invalid"),
D&&(!["string","number"].includes(E.V=typeof r[0].id)&&N("item id type invalid"),E.keys=K(r[0]).join(",")));for(var v of r)v===C&&N("item is null"),typeof v!==E.P&&N("item type changed"),D&&(typeof v.id!==E.V&&N("item id type changed"),K(v).join(",")!==E.keys&&N("item keys differ of "+v.id));for(var L of r)v=D?L.id:L,v in m&&N("item key not unique: "+v),m[v]=L,n.push(v)}L=D;u||Y();if(l.J){Q=p&&l.L(p,l.O);for(var R of l.N)R in m||(X(l.J[R],a),delete l.J[R]);l.O=p;l.N=n}else l.J={},l.T=L?P(m[n[0]]):
C,l.N=n,l.L=(l.O=p)&&P(p);for(R=c.h=new H(u);0<u;){v=n[--u];r=l.J[v];if(e=!r)l.J[v]=d=r={o:{u:q,l:J({I:m[v]},p)},L:C,B:c,s:t,K:u,M:[],h:C,g:C,i:C,v:G},W(a,b),r.g&&a.insertBefore(r.i=r.g,b);else if((D=ta(r))&&D.nextSibling!==b&&ua(r,a,b),Q||L&&l.T(m[v],r.o.l.I))(d=r).o.l=J({I:m[v]},p),W(a,b);(R[r.K=u]=r).i&&(b=r.i)}c.i=b!==f?b:C}}},X=(a,b)=>{b&&a.g&&(a.g.remove(),b=C);if(a.h)for(var c of a.h)c&&X(c,b);b=a.M;let f=b.length;for(;1<f;)switch((c=b[--f]).A){case 3:c.G&&c.G(...c.m);break;case 4:c.m=B}if(a.v){let t,
m;(!(m=y[t=a.s])||0>(t=m.indexOf(a)))&&(!(m=z[t])||0>(t=m.indexOf(a)))||m.splice(t,1)}},ta=a=>{if(a.g)return a.g;let b;a=(b=a.h)?b.length:0;let c,f;for(;0<a;)if((f=b[--a])&&(c=ta(f)))return c;return C},ua=(a,b,c)=>{if(a.g)return b.insertBefore(a.g,c);if(a.i){let f=a.h.length;do a.h[--f]&&(c=ua(a.h[f],b,c));while(0<f)}return c},Z=a=>!a.v&&(a.v=F,y[a.s]?y[a.s].push(a):y[a.s]=[a],x||va()),Y=a=>(T(6,C),(h<g.length?g[h++]:g[h++]={A:6,j:void 0===a?{}:a}).j),U=(a,b)=>(T(9,C),h<g.length?(b=g[h].j,g[h++].j=
a):g[h++]={A:9,j:a},b),wa=a=>{"object"===typeof a&&a||N("object required");const b=U(a,C);return b?ra(b,a):K(a)},xa=a=>{V(!a,"attributes presence");const b=d.g;if(a){for(const c of wa(a)){1<c.length&&c.charAt(0).toLowerCase()!==c.charAt(0)&&N("capital prop: "+c);switch(c.charCodeAt(0)){case 70:"object"===typeof a.F&&a.F||N("invalid css flags");b.className=K(a.F).filter(f=>a.F[f]).join(" ");continue;case 82:"function"!==typeof a.R&&N("invalid ref"),a.R(b);case 67:case 68:case 83:continue}97>c.charCodeAt(0)&&
N("invalid prop: "+c);b[c]=a[c]}V(!a.D,"dataset presence");if(a.D)for(const c of wa(a.D))b.dataset[c]=a.D[c];V(!a.S,"style presence");if(a.S)for(const c of wa(a.S))b.style[c]=a.S[c]}return b},ya=(a,b,c)=>("string"===typeof a&&N("component expected, use node_dom instead"),c&&c.constructor!==H&&N("invalid childs type"),{u:a,l:b?c?(b.C=c,b):b:c?{C:c}:C}),va=()=>{e=0>=k;k=ia.now();w&&cancelAnimationFrame(w);x=F;w=0;var a;let b=0;for(;(a=y).length;){10<++b&&N("rerender loop detected");y=[];for(const c of a)if(c)for(d of c)if(d.v){if(d.g)W(C,
C);else{let f=C,t=d.i,m=d,n=d;for(;!(a=(m=m.B).g););do{let q=n.K;const {h:l}=n=n.B,u=l.length;for(;++q<u&&l[q]&&!(f=l[q].i););}while(!f&&n!==m);n=d;W(a,f);if(n.i!==t)for(;!(n=n.B).g;){t=C;for(const q of n.h)if(q&&(t=q.i))break;if(t===n.i)break;n.i=t}}e=G}}x=G;d=g=C;z.length&&(y=z,z=a,za())},za=()=>w||(w=requestAnimationFrame(va)),Aa=a=>{var b=A[a];if(!b){a.startsWith("#")&&N("dom: unknown handle");const c=a.indexOf("[");b=0>c?a:a.substr(0,c);(0===b.length||b!==b.toLowerCase()||b.includes(" ")||b.includes("#")||
b.includes("."))&&N("dom: invalid tag");A[a]=b=ha.createElement(b);if(0<c){!a.endsWith("]")&&N("dom: ] missing");for(const f of a.substring(c+1,a.length-1).split("]["))!f&&N("dom: empty attribute"),(f.includes("[")||f.includes("]"))&&N("dom: attributes screwed up"),a=f.indexOf("="),f.includes(" ")&&(0>a||f.indexOf(" ")<a)&&N("dom: space in attribute name"),0<a?b[f.substr(0,a)]=f.substr(a+1):b[f]=F}}return b},Ba=a=>{a&&"string"===typeof a||N("dom: descriptor string expected");let b=aa[a];if(!b){const c=
Aa(a);aa[a]=b=f=>(e&&(d.g=c.cloneNode(F)),xa(f),f&&f.C||C);b.name_="$"+a}return b};M.onerror=()=>(d&&ma("error in component"),y=z=[],G);M.lui={defer:()=>(d&&N("defer while rendering"),x=F,za()),defer_end:()=>(d&&N("defer_end while rendering"),x||N("nothing was deferred"),va()),dom_define:(a,b,c)=>{A["#"+a]&&N("dom_define: handle exists");b=Aa(b);c&&(c&&(c.C&&N("dom_define cannot have childs"),c.R&&N("dom_define cannot have a ref")),b=b.cloneNode(F),c.D&&(J(b.dataset,c.D),delete c.D),c.S&&(J(b.style,c.S),delete c.S),J(b,c));A["#"+a]=b},hook_assert:a=>{T(C,C);if(!a)throw A;},hook_async:(a,b,c)=>{T(4,b);let f;const t=ka();if((h<g.length?
(f=g[h++],G):f=g[h++]={A:4,H:sa(b),m:b||B,j:C})||b&&f.H(f.m,b)&&(f.m=b)){void 0!==c&&(f.j=c);const m=d;a(...f.m).then(n=>f.j!==n&&f.m===b&&(f.j=n,Z(m))).catch(n=>{na(t);throw n;})}return f.j},hook_dom:(a,b)=>(T(C,C),d.g?e&&d.B&&N("hook_dom called twice"):e||N("hook_dom skipped before"),b&&(b.C&&N("hook_dom cannot have childs"),b.R&&N("hook_dom cannot have a ref")),d.g===C&&(d.g=Aa(a).cloneNode(F)),xa(b||C)),hook_effect:(a,b)=>{T(3,b);if(h>=g.length)g[h]={A:3,H:sa(b),m:b=b||B,G:a(...b)||C};else if(b){const c=
g[h];c.H(c.m,b)&&(c.G&&c.G(...c.m),c.G=a(...(c.m=b))||C)}g[h].G?.then&&N("effect function must be synchronous");++h},hook_memo:(a,b)=>(T(8,b),h>=g.length?(g[h++]={A:8,H:sa(b),m:b=b||B,j:a(...b)}).j:b&&g[h].H(g[h].m,b)?g[h].j=a(...(g[h++].m=b)):g[h++].j),hook_model:a=>{T(10,C);"object"===typeof a&&a||N("mutations object required");"function"!==typeof a.init&&N("init mutation required for initial value");if(h<g.length)return g[h++].j;const b=d,c=ka(),f=[S(a.init,[C],c+" -> #init"),{}];S(O,[f[0]],c+
" -> #init");for(const t of K(a))f[1][t]=(...m)=>{m=S(a[t],[f[0],...m],c+" -> #"+t);f[0]!==m&&(S(O,[m],c+" -> #"+t),f[0]=m,Z(b))};g[h++]={A:10,j:f};return f},hook_prev:U,hook_rerender:()=>{T(C,C);const a=d;a.v=F;z[a.s]?z[a.s].push(a):z[a.s]=[a]},hook_state:a=>{T(5,C);if(h<g.length)return g[h++].j;const b=d,c=[a,f=>{c[0]!==f&&(c[0]=f,Z(b))},()=>c[0]];g[h++]={A:5,j:c};return c},hook_static:Y,init:(a,b=ha.body,c=C)=>{"function"!==typeof a&&N("no init function specified");b.innerHTML!=C||N("invalid component_ element");
b._lui_used&&N("root element already mounted");b._lui_used=1;b.innerHTML="";b={o:{u:a,l:c},L:C,B:C,s:0,K:0,M:[],h:C,g:b,i:b,v:G};a.name_="$root";d=g=C;Z(b)},node:ya,node_dom:(a,b,c)=>ya(Ba(a),b,c),node_map:(a,b,c)=>ya(P,{u:a,U:b,l:c||C}),now:()=>k}}